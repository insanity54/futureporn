import YoutubeDlWrap from "youtube-dl-wrap";
import EventEmitter from "node:events";
import { spawn as spawn$0 } from "child_process";
import stream from "stream";
import os from "os";
import fs from "fs";
import path from "path";
import * as debug$0 from "debug";
import * as rxjs from "rxjs";
import * as operators from "rxjs/operators";
import download from "./download";
import mqtt from "./mqtt";
const youtubedl = new YoutubeDlWrap();
const helloThereVideo = 'https://www.youtube.com/watch?v=rpXMSIYDx3I';
const cbMel = 'https://chaturbate.com/projektmelody/';
const testStream = 'https://chaturbate.com/milanaaafit/';
const spawn = { spawn: spawn$0 }.spawn;
const Readable = stream.Readable;
const debug = debug$0('voddo');
const { Observable, defer, timer, interval, of, config } = rxjs;
const { repeat, retry, delay, retryWhen, pipe, catchError, throwError, mergeMap, tap } = operators;
const { mqttFactory } = mqtt;
const offlineRegex = /ERROR:.*offline/;
const destinationRegex = /Destination:\s+(.+\.\S+)/;
const fakePath = '/tmp/projektmalady 2021-01-01 fakevid.mp4';
const isObserving = true;
class VoddoEmitter extends EventEmitter {}
class Voddo {
    constructor(opts) {
        this.ee = new VoddoEmitter();
        this.url = opts.url;
        this.format = opts.format || 'best';
        this.cwd = opts.cwd || os.tmpdir();
        this.mqPassword = opts?.mqPassword;
        this.mqUrl = opts?.mqUrl;
        this.mqUsername = opts?.mqUsername;
        this.mqClient = null;
    }
    async initMq() {
        this.mqClient = await mqttFactory(this.mqUrl, this.mqUsername, this.mqPassword);
    }
    /**
     * observe the ffmpeg instance
     * act on it's emissions (new video file created on disk)
     *
     * observable emissions
     *   new video --> next
     *
     */
    observe() {
        const observer = {
            next: function (value) {
                debug(`  [*>>>>>>>] next! ${value}`);
            },
            complete: function () {
                debug(`  [*>>>>>>>] completed!`);
            }
        };
        const source = Observable.create((obs) => {
            console.log('  [*] the beautiful act of creation!');
            const ee = download(this.url, this.format, this.cwd);
            ee.on('youtubeDlEvent', (eventType, eventData) => {
                debug(`  [*] youtubeDlEvent was JUST emitted. eventType:${eventType}, eventData:${eventData}`);
                if (eventType === 'download' && eventData.includes('Destination:')) {
                    obs.next(/Destination:\s(.*)$/.exec(eventData)[1]);
                }
            });
            ee.on('error', (err) => {
                debug('  [*] error');
                debug(err);
                obs.error(err);
            });
            ee.on('close', () => {
                debug('  [*] got a close event');
                obs.complete();
            });
        });
        config.onUnhandledError = ((err) => {
            console.error('  [***] UNHANDLED ERROR');
            console.error(err);
        });
        // const sampleSource = interval(1000)
        //   .pipe(
        //     mergeMap(val => val > 5 ? throwError(() => 'Error!') : of(val)),
        //   )
        const backoffTimer = (err, count) => {
            if (typeof count === 'undefined')
                count = err;
            const delayTime = Math.min(600000, 2 ^ count * 10000);
            debug(`  [b] backoffTimer is going to delay for ${delayTime}ms. count:${count}, err:${err}`);
            console.log('backupfoaifjaof timer!!!!');
            return timer(delayTime); // back-off timer maxing out at 10 mins
        };
        // return an Observable which repeats forever regardless of complete or error
        const result = source
            .pipe(retry({
            delay: ((err, retryCount) => timer(Math.min(600000, 2 ^ retryCount * 1000)))
        })).subscribe(observer);
        return result;
    }
    parseOutput = (output) => {
        let r = destinationRegex.exec(output);
        if (!r) {
            throw new Error('destination filename could not be found in the ffmpegWrapper output');
        }
        return r[1];
    };
    sleepFor = async (ms = 1000) => {
        debug(`  [*] sleeping for ${ms}ms`);
        return new Promise((resolve) => {
            setTimeout(() => {
                debug(`  [*] sleep finished`);
                resolve();
            }, ms);
        });
    };
}
export default Voddo;
